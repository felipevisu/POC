import { transform } from "@wyw-in-js/transform";
import { readFileSync, writeFileSync, existsSync, mkdirSync } from "fs";
import { join, dirname } from "path";
import { glob } from "glob";

class SimpleWywBundler {
  constructor(config = {}) {
    this.config = {
      // Input/Output paths
      input: config.input || "src/**/*.{js,jsx,ts,tsx}",
      outputCSS: config.outputCSS || "dist/styles.css",

      // WyW-in-JS configuration
      evaluate: config.evaluate !== false,
      displayName: config.displayName !== false,

      // Babel configuration for WyW-in-JS
      babelConfig: config.babelConfig || {
        presets: [
          "@linaria",
          ["@babel/preset-react", { runtime: "automatic" }],
          "@babel/preset-typescript",
        ],
        plugins: [],
      },

      ...config,
    };

    this.cssMap = new Map();
  }

  async processFile(filePath) {
    try {
      const content = readFileSync(filePath, "utf8");

      // Skip files without CSS-in-JS imports
      if (!this.hasCSSInJS(content)) {
        return null;
      }

      console.log(`Processing: ${filePath}`);

      // Transform with WyW-in-JS
      const result = await transform(
        {
          options: {
            filename: filePath,
            pluginOptions: {
              babelOptions: this.config.babelConfig,
              displayName: this.config.displayName,
              evaluate: this.config.evaluate,
            },
          },
        },
        content,
        {}
      );

      // Store extracted CSS
      if (result.cssText) {
        this.cssMap.set(filePath, {
          css: result.cssText,
          dependencies: result.dependencies || [],
          sourceMap: result.sourceMap || null,
        });

        return result;
      }

      return null;
    } catch (error) {
      console.error(`Error processing ${filePath}:`, error.message);
      return null;
    }
  }

  hasCSSInJS(content) {
    const patterns = [
      /import.*['"]@wyw-in-js/,
      /import.*['"]@linaria/,
      /import.*styled.*from/,
      /import.*css.*from/,
      /styled\./,
      /css`/,
      /styled\(/,
    ];

    return patterns.some((pattern) => pattern.test(content));
  }

  getFiles() {
    return glob.sync(this.config.input, {
      nodir: true,
      absolute: true,
    });
  }

  async bundle() {
    console.log("ðŸŽ¨ Starting WyW-in-JS CSS extraction...\n");

    // Get all files
    const files = this.getFiles();
    console.log(`Found ${files.length} files to scan\n`);

    // Process each file
    for (const file of files) {
      await this.processFile(file);
    }

    // Combine CSS
    const finalCSS = this.combineCSS();

    // Write output
    this.writeOutput(finalCSS);

    console.log(`\nâœ… CSS bundle created: ${this.config.outputCSS}`);
    console.log(`   Total files processed: ${files.length}`);
    console.log(`   Files with CSS: ${this.cssMap.size}`);
    console.log(`   Bundle size: ${(finalCSS.length / 1024).toFixed(2)} KB`);

    return {
      css: finalCSS,
      filesProcessed: files.length,
      filesWithCSS: this.cssMap.size,
      outputPath: this.config.outputCSS,
    };
  }

  combineCSS() {
    let combined = "";

    // Add header
    combined += "/* Generated by WyW-in-JS CSS Bundler */\n";
    combined += `/* Generated at: ${new Date().toISOString()} */\n\n`;

    // Add CSS from each file
    for (const [filePath, data] of this.cssMap) {
      combined += `/* Source: ${filePath} */\n`;
      combined += data.css;
      combined += "\n\n";
    }

    return combined;
  }

  writeOutput(css) {
    const outputDir = dirname(this.config.outputCSS);

    // Create directory if needed
    if (!existsSync(outputDir)) {
      mkdirSync(outputDir, { recursive: true });
    }

    // Write CSS file
    writeFileSync(this.config.outputCSS, css);
  }
}

export { SimpleWywBundler };

// CLI usage
if (import.meta.url === `file://${process.argv[1]}`) {
  async function run() {
    const bundler = new SimpleWywBundler({
      input: "src/**/*.{js,jsx,ts,tsx}",
      outputCSS: "dist/bundle.css",
    });

    await bundler.bundle();
  }

  run().catch(console.error);
}
